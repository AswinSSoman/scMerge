# if (min(m - ncol(M), sum(ctl)) <= 150) {
#   rsvd_k <- 150
# } else {
#   rsvd_k <- sum(ctl)
# }
propEigen = 0.1
rsvd_k = min(m - ncol(M), sum(ctl), ceiling(propEigen*min(dim(Y0))))
####################
## KW: At the advice of JO, q should not be lowered.
# if (nrow(M) >= 300) {
#   rvsd_q <- 1
# } else {
#   rvsd_q <- 2
# }
####################
fullalpha <- t(rsvd::rsvd(Y0 %*% t(Y0), k = rsvd_k, q = 2)$u[, 1:rsvd_k, drop = FALSE]) %*% Y
}
alpha <- fullalpha[1:min(k, nrow(fullalpha)), , drop = FALSE]
ac <- alpha[, ctl, drop = FALSE]
W <- Y[, ctl] %*% t(ac) %*% solve(ac %*% t(ac))
newY <- Y - W %*% alpha
}
if (average) {
newY <- ((1 / apply(M, 2, sum)) * t(M)) %*% newY
}
if (!return.info) {
return(newY)
} else {
return(list(
newY = newY, M = M, fullalpha = fullalpha,
rsvd_k_options = c(
"m-ncol(M)" = m - ncol(M),
"sum(ctl)" = sum(ctl),
"rsvd_prop_propEigen" = ceiling(propEigen*min(dim(Y0))))
)
)
}
}
residop_fast <-
function(A, B) {
return(A - B %*% solve(t(B) %*% B) %*% (t(B) %*% A))
}
tological <-
function(ctl, n) {
ctl2 <- rep(FALSE, n)
ctl2[ctl] <- TRUE
return(ctl2)
}
library(roxygen2)
roxygenise()
library(roxygen2)
roxygenise()
library(scMerge)
help(scMerge)
require(SingleCellExperiment)
# Loading example data
data("sce_mESC")
# Previously computed stably expressed genes
data("segList_ensemblGeneID")
# Running an example data with minimal inputs
sce_mESC<- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge",fast_svd = FALSE)
sce_mESC <- runPCA(sce_mESC, exprs_value = "scMerge")
library(scater)
sce_mESC <- runPCA(sce_mESC, exprs_value = "scMerge")
plotPCA(sce_mESC)
library(scMerge)
require(SingleCellExperiment)
data("sce_mESC")
data("segList_ensemblGeneID")
sce_mESC<- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge")
scMerge()
sce_mESC
scater::plotPCA(sce_mESC)
scater::plotPCA(sce_mESC, "counts")
?plotPCA
scater::plotPCA(sce_mESC, exprs_values = "counts")
scater::plotPCA(sce_mESC, exprs_values = "logcounts")
scater::plotPCA(sce_mESC, exprs_values = "logcounts", colour_by = "batch", shape = "cell_type")
scater::plotPCA(sce_mESC, exprs_values = "logcounts", colour_by = "batch", shape = "cellTypes")
scater::plotPCA(sce_mESC, exprs_values = "scMerge", colour_by = "batch", shape = "cellTypes")
scater::plotPCA(sce_mESC, exprs_values = "scMerge", colour_by = "cellTypes", shape = "batch")
library(roxygen2)
library(scMerge)
sce_combine = sce_mESC;
ctl = segList_ensemblGeneID$mouse$mouse_scSEG;
kmeansK = c(1,3,3,1,1);
assay_name = c("scMerge_k10", "scMerge_k20");
exprs = "logcounts";
hvg_exprs = "counts";
marker = NULL;
marker_list = NULL;
ruvK = c(10, 20);
replicate_prop = 0.5;
cell_type = NULL;
cell_type_match = FALSE;
cell_type_inc = NULL;
fast_svd = FALSE;
propEigen = 0.1;
dist = "cor";
WV = NULL;
WV_marker = NULL;
return_all_RUV = FALSE;
return_sce = TRUE
## Checking input expression
if(is.null(exprs)){
stop("exprs is NULL.")
}
if(is.null(assay_name)){
stop("assay_name is NULL")
}
if(return_all_RUV){
message("You chose return_all_RUV = TRUE, the result will contain all RUV computations. This could be a very large object.")
## We need an assay_name for every ruvK, if return_all_RUV is TRUE
if(length(assay_name) != length(ruvK)){
stop("You chose return_all_RUV = TRUE. In this case, the length of assay_name must be equal to the length of ruvK")
}
}
## Checking input expression assay name in SCE object
if(!exprs %in% assayNames(sce_combine)){
stop(paste("No assay named", exprs))
}
## Extracting data matrix from SCE object
exprs_mat <- SummarizedExperiment::assay(sce_combine, exprs)
sce_rownames <- rownames(sce_combine)
## Checking if any rows or columns are purely zeroes
if (sum(rowSums(exprs_mat) == 0) != 0 | sum(colSums(exprs_mat) == 0) != 0) {
stop("There are rows or columns that are all zeros. Please remove it.")
}
## Checking negative controls input
if (is.null(ctl)) {
stop("Negative control genes are needed. \n")
} else {
if (class(ctl) == "character") {
ctl <- which(sce_rownames %in% ctl)
}
if (length(ctl) == 0) {
stop("Could not find any negative control genes in the row names of the expression matrix", call. = FALSE)
}
}
## Checking the batch info
if (is.null(sce_combine$batch)) {
stop("Could not find a 'batch' column in colData(sce_combine)", call. = FALSE)
}
if(class(sce_combine$batch) == "factor"){
sce_batch <- droplevels(sce_combine$batch)
} else {
sce_batch <- sce_combine$batch
}
## Finding pseudo-replicates
repMat <- scReplicate(sce = sce_combine,
batch = sce_batch,
kmeansK = kmeansK,
exprs = exprs,
hvg_exprs = hvg_exprs,
marker = marker,
marker_list = marker_list,
replicate_prop = replicate_prop,
cell_type = cell_type,
cell_type_match = cell_type_match,
cell_type_inc = cell_type_inc,
dist = dist,
WV = WV,
WV_marker = WV_marker)
cat("Dimension of the replicates mapping matrix \n")
print(dim(repMat))
cat("\n")
## Performing RUV normalisation
cat("Performing RUV normalisation... This might take a few minutes... \n")
ruv3res <- scRUVIII(Y = t(exprs_mat),
M = repMat,
ctl = ctl,
k = ruvK,
batch = sce_batch,
fullalpha = NULL,
cell_type = cell_type,
return.info = TRUE,
return_all_RUV = return_all_RUV,
fast_svd = fast_svd,
propEigen = propEigen)
# YXL: NEED FIX
##
# if (return_all_RUV) {
#   return(res = list(
#     scRUV = ruv3res,
#     mnc = mnc,
#     kmeans = kmeans_res
#   ))
# }
# if (return_sce) {
#   if (is.null(assay_name)) {
#     assay_name <- paste("scMerge_RUVk", ruv3res$k, sep = "")
#   }
#   assay(sce_combine, assay_name) <- t(ruv3res$newY)
#   cat(paste("Return assay named \n", assay_name))
#   return(sce_combine)
# } else {
#   return(res = list(
#     normalised_matrix = ruv3res$newY,
#     scRUV_res = ruv3res,
#     scRep_res = repMat
#   ))
# } ## End return_sce criterion
roxygenise()
ruv3res <- scRUVIII(Y = t(exprs_mat),
M = repMat,
ctl = ctl,
k = ruvK,
batch = sce_batch,
fullalpha = NULL,
cell_type = cell_type,
return.info = TRUE,
return_all_RUV = return_all_RUV,
fast_svd = fast_svd,
propEigen = propEigen)
sce_final_result = sce_combine
ruv3res
ruvK
return_all_RUV
return_all_RUV = TRUE
if(return_all_RUV){
message("You chose return_all_RUV = TRUE, the result will contain all RUV computations. This could be a very large object.")
## We need an assay_name for every ruvK, if return_all_RUV is TRUE
if(length(assay_name) != length(ruvK)){
stop("You chose return_all_RUV = TRUE. In this case, the length of assay_name must be equal to the length of ruvK")
}
}
sce_final_result = sce_combine
if(!return_all_RUV){
## If return_all_RUV is FALSE, then scRUVIII should've just returned with a single result (ruv3res_optimal)
assay(sce_final_result, assay_name) <- t(ruv3res$newY)
metadata(sce_final_result) = list(
"ruvK" = ruvK,
"ruvK_optimal" = ruv3res$optimal_ruvK
)
} else{
## if return_all_RUV is TRUE, then the previous check ensured assay_name is not NULL and matches the length of ruvK
## And the scRUVIII should've just returned with a single result (ruv3res_optimal)
listNewY = lapply(ruv3res[names(ruv3res) != "optimal_ruvK"], function(x){t(x$newY)})
for(i in 1:length(listNewY)){
assay(sce_final_result, assay_name[i]) <- listNewY[[i]]
}
}
return_all_RUV
ruv3res <- scRUVIII(Y = t(exprs_mat),
M = repMat,
ctl = ctl,
k = ruvK,
batch = sce_batch,
fullalpha = NULL,
cell_type = cell_type,
return.info = TRUE,
return_all_RUV = return_all_RUV,
fast_svd = fast_svd,
propEigen = propEigen)
sce_final_result = sce_combine
return_all_RUV
## if return_all_RUV is TRUE, then the previous check ensured assay_name is not NULL and matches the length of ruvK
## And the scRUVIII should've just returned with a single result (ruv3res_optimal)
listNewY = lapply(ruv3res[names(ruv3res) != "optimal_ruvK"], function(x){t(x$newY)})
assay_name
## if return_all_RUV is TRUE, then the previous check ensured assay_name is not NULL and matches the length of ruvK
## And the scRUVIII should've just returned with a single result (ruv3res_optimal)
listNewY = lapply(ruv3res[names(ruv3res) != "optimal_ruvK"], function(x){t(x$newY)})
for(i in 1:length(listNewY)){
assay(sce_final_result, assay_name[i]) <- listNewY[[i]]
}
sce_final_result
ruv3res$optimal_ruvK
ruvK
sce_final_result = sce_combine
if(!return_all_RUV){
## If return_all_RUV is FALSE, then scRUVIII should've just returned with a single result (ruv3res_optimal)
assay(sce_final_result, assay_name) <- t(ruv3res$newY)
} else{
## if return_all_RUV is TRUE, then the previous check ensured assay_name is not NULL and matches the length of ruvK
## And the scRUVIII should've just returned with a single result (ruv3res_optimal)
listNewY = lapply(ruv3res[names(ruv3res) != "optimal_ruvK"], function(x){t(x$newY)})
for(i in 1:length(listNewY)){
assay(sce_final_result, assay_name[i]) <- listNewY[[i]]
} ## End for loop
}
metadata(sce_final_result) = list(
"ruvK" = ruvK,
"ruvK_optimal" = ruv3res$optimal_ruvK
)
sce_final_result
sce_final_result %>% metadata()
library(magrittr)
sce_final_result %>% metadata()
library(roxygen2)
roxygenise()
roxygenise()
repMat
roxygenise()
help(scMerge)
help("scMerge")
sce_final_result
roxygenise()
roxygenise()
roxygenise()
library(pkgdown)
build_site()
roxygenise()
?person
roxygenise()
build_site()
library(roxygen2)
roxygenise()
install.packages("doSNOW")
install.packages("distr")
install.packages("distr")
roxygenise()
?scMerge
suppressPackageStartupMessages({
library(SingleCellExperiment)
library(scater)
})
# Loading example data
data("sce_mESC")
# Previously computed stably expressed genes
data("segList_ensemblGeneID")
# Running an example data with minimal inputs
sce_final_result = sce_combine
sce_mESC_normalised = scMerge(
sce_combine = sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge", fast_svd = TRUE)
if(!return_all_RUV){
## If return_all_RUV is FALSE, then scRUVIII should've just returned with a single result (ruv3res_optimal)
assay(sce_final_result, assay_name) <- t(ruv3res$newY)
} else{
## if return_all_RUV is TRUE, then the previous check ensured assay_name is not NULL and matches the length of ruvK
## And the scRUVIII should've just returned with a single result (ruv3res_optimal)
listNewY = lapply(ruv3res[names(ruv3res) != "optimal_ruvK"], function(x){t(x$newY)})
for(i in 1:length(listNewY)){
assay(sce_final_result, assay_name[i]) <- listNewY[[i]]
} ## End for loop
}
scater::plotPCA(sce_mESC_normalised, colour_by = "cellTypes", shape = "batch",
run_args = list(exprs_values = "logcounts"))
scater::plotPCA(sce_mESC_normalised, colour_by = "cellTypes", shape = "batch",
run_args = list(exprs_values = "logcounts"))
metadata(sce_final_result) = list(
"ruvK" = ruvK,
"ruvK_optimal" = ruv3res$optimal_ruvK,
"scRep_res" = repMat
)
pkgdown::build_site()
library(scMerge)
library(roxygen2)
roxygenise()
library(scMerge)
library(SingleCellExperiment)
library(scater)
# mouse ESC data
data("sce_mESC")
# single-cell stably expressed gene list
data("segList_ensemblGeneID")
sce_mESC
scater::plotPCA(sce_mESC, colour_by="cellTypes", shape_by = "batch")
sce_mESC
table(sce_mESC$batch)
sce_mESC <- scMerge(sce_combine = sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_unsupervised")
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch")
sce_mESC <- scater::runPCA(sce_mESC,
exprs_values = "scMerge_unsupervised")
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch")
sce_mESC
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_unsupervised_all",
replicate_prop = 1)
sce_mESC <- scater::runPCA(sce_mESC,
exprs_values = "scMerge_unsupervised_all")
scater::plotPCA(sce_mESC, colour_by="cellTypes",shape_by="batch")
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_supervised",
cell_type = sce_mESC$cellTypes)
sce_mESC <- scater::runPCA(sce_mESC,
exprs_values = "scMerge_supervised")
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch")
sce_mESC
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_semisupervised1",
cell_type = sce_mESC$cellTypes,
cell_type_inc = which(sce_mESC$cellTypes == "2i"))
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_semisupervised2",
cell_type = sce_mESC$cellTypes,
cell_type_match = TRUE)
sce_mESC <- scater::runPCA(sce_mESC,
exprs_values = "scMerge_semisupervised2")
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch")
t1 = Sys.time()
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_unsupervised_all")
t2 = Sys.time()
t2 - t1
dim(sce_mESC)
t1 = Sys.time()
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_unsupervised_all",
fast_svd = TRUE,
rsvd_prop = 0.1)
t2 = Sys.time()
t2 - t1
t1 = Sys.time()
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_unsupervised_all",
fast_svd = TRUE,
rsvd_prop = 0.05)
t2 = Sys.time()
t2 - t1
t1 = Sys.time()
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_fast",
fast_svd = TRUE,
rsvd_prop = 0.05)
t2 = Sys.time()
t2 - t1
sce_mESC <- scater::runPCA(sce_mESC,
exprs_values = "scMerge_fast")
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch")
t1 = Sys.time()
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_fast",
fast_svd = TRUE,
rsvd_prop = 0.01)
t2 = Sys.time()
t2 - t1
sce_mESC <- scater::runPCA(sce_mESC,
exprs_values = "scMerge_fast")
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch")
sce_mESC <- scater::runPCA(sce_mESC,
exprs_values = "scMerge_classical")
t1 = Sys.time()
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_classical")
t2 = Sys.time()
t2 - t1
sce_mESC <- scater::runPCA(sce_mESC,
exprs_values = "scMerge_classical")
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch")
roxygenise()
library(devtools)
build_vignettes()
roxygenise()
build_vignettes()
pkgdown::build_site()
build_vignettes()
pkgdown::build_site()
pkgdown::build_site()
vignette("scMerge")
library(scMerge)
vignette("scMerge")
vignette(scMerge)
library(pkgdown)
pkgdown::build_article("vignettes/gallery/Mouse_Embyronic_Data.Rmd")
?pkgdown::build_article
pkgdown::build_article("gallery/Mouse_Embyronic_Data.Rmd")
pkgdown::build_article("gallery/Mouse_Embyronic_Data")
pkgdown::build_home()
?person
?build_site
navbar
?navbar
build_home
build_home()
build_home()
