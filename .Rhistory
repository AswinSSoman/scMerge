library(roxygen2)
roxygenise()
library(BiocInstaller)
biocLite("rsvd")
biocLite("sm")
library(ruv)
library(rsvd)
libraru(SingleCellExperiment)
library(SingleCellExperiment)
library(igraph)
library(pdist)
library(proxy)
install.packages("proxy")
library(BiocInstaller)
library(roxygen2)
roxygenise()
library(BiocInstaller)
biocLite("kBET")
biocLite("kBET")
biocLite("M3Drop")
biocLite("bbmle")
## try http:// if https:// URLs are not supported
source("https://bioconductor.org/biocLite.R")
biocLite("M3Drop")
install.packages("bbmle")
## try http:// if https:// URLs are not supported
source("https://bioconductor.org/biocLite.R")
biocLite("M3Drop")
library(devtools)
install_github('theislab/kBET')
library(devtools)
install_github('theislab/kBET')
library(devtools)
install_github('theislab/kBET')
## try http:// if https:// URLs are not supported
source("https://bioconductor.org/biocLite.R")
biocLite("M3Drop")
## try http:// if https:// URLs are not supported
source("https://bioconductor.org/biocLite.R")
biocLite("M3Drop")
library(M3Drop)
library(scMerge)
library(roxygen2)
roxygenise()
?scMerge
roxygenise()
roxygenise()
Sys.which("git")
library(devtools)
install_github('SydneyBioX/scMerge')
?Steop
?stop
?assay
roxygen2::roxygenise()
library(scMerge)
assay
example("scMerge")
example(scMerge)
example()
examples()
?scMerge
roxygen2::roxygenise()
require(SingleCellExperiment)
#Loading example data
data("sce_mESC")
data("segList_ensemblGeneID")
#scMerge
sce_mESC<- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scRUV")
ruv::RUVIII
library(roxygen2)
roxygenise()
ruv::residop()
ruv::residop
library(scMerge)
roxygenise()
library(scMerge)
ruv::RUVIII
library(orxy)
library(roxygen2)
roxygenise()
svd(diag(1,1000))
tmp1 = microbenchmark::microbenchmark(svd(diag(1,500)), times = 100)
tmp1 = microbenchmark::microbenchmark(svd(diag(1,100)), times = 100)
tmp2 = microbenchmark::microbenchmark(rsvd::rsvd(diag(1,100)), times = 100)
tmp1
tmp2
set.seed(1)
x = matrix(rnorm(100*100), ncol = 100)
tmp1 = microbenchmark::microbenchmark(svd(x), times = 100)
tmp2 = microbenchmark::microbenchmark(rsvd::rsvd(x), times = 100)
tmp1
tmp2
library(scMerge)
install.packages(c("ruv", "rsvd", "igraph", "pdist", "proxy"))
devtools::install_github("theislab/kBET")
source("https://bioconductor.org/biocLite.R")
biocLite(c("SingleCellExperiment", "M3Drop"))
devtools::install_github("SydneyBioX/scMerge")
devtools::install_github("SydneyBioX/scMerge")
install.packages("roxygen2")
library(roxygen2)
roxygenise()
roxygenise()
#' fastRUVIII
#'
#' perform fastRUVIII
#'
#'
#' @author Yingxin Lin
#' @export
fastRUVIII <-
function(Y, M, ctl, k = NULL, eta = NULL, include.intercept = TRUE,
average = FALSE, fullalpha = NULL, return.info = FALSE, inputcheck = TRUE) {
if (is.data.frame(Y)) {
Y <- data.matrix(Y)
}
m <- nrow(Y)
n <- ncol(Y)
M <- ruv::replicate.matrix(M)
ctl <- tological(ctl, n)
if (inputcheck) {
if (m > n) {
warning("m is greater than n!  This is not a problem itself, but may indicate that you need to transpose your data matrix.  Please ensure that rows correspond to observations (e.g. microarrays) and columns correspond to features (e.g. genes).")
}
if (sum(is.na(Y)) > 0) {
warning("Y contains missing values.  This is not supported.")
}
if (sum(Y == Inf, na.rm = TRUE) + sum(Y == -Inf, na.rm = TRUE) >
0) {
warning("Y contains infinities.  This is not supported.")
}
}
Y <- ruv::RUV1(Y, eta, ctl, include.intercept = include.intercept)
if (ncol(M) >= m) {
newY <- Y
} else if (is.null(k)) {
ycyctinv <- solve(Y[, ctl] %*% t(Y[, ctl]))
newY <- (M %*% solve(t(M) %*% ycyctinv %*% M) %*% (t(M) %*%
ycyctinv)) %*% Y
fullalpha <- NULL
}
else if (k == 0) {
newY <- Y
fullalpha <- NULL
}
else {
if (is.null(fullalpha)) {
# Y0 = residop_fast(Y, M)
# if(min(m - ncol(M),sum(ctl))<=150){ rsvd_k=150}else{rsvd_k=min(m - ncol(M),sum(ctl))}
# fullalpha = t(rsvd(Y0 %*% t(Y0),k=rsvd_k)$u[, 1:min(m - ncol(M),
#    sum(ctl)), drop = FALSE]) %*% Y
Y0 <- residop_fast(Y, M)
####################
## KW: This switch was changed from sum(ctl) to 0.1*min(dim(Y0)), as we need to work with more data
# if (min(m - ncol(M), sum(ctl)) <= 150) {
#   rsvd_k <- 150
# } else {
#   rsvd_k <- sum(ctl)
# }
propEigen = 0.1
rsvd_k = min(m - ncol(M), sum(ctl), ceiling(propEigen*min(dim(Y0))))
####################
## KW: At the advice of JO, q should not be lowered.
# if (nrow(M) >= 300) {
#   rvsd_q <- 1
# } else {
#   rvsd_q <- 2
# }
####################
fullalpha <- t(rsvd::rsvd(Y0 %*% t(Y0), k = rsvd_k, q = 2)$u[, 1:rsvd_k, drop = FALSE]) %*% Y
}
alpha <- fullalpha[1:min(k, nrow(fullalpha)), , drop = FALSE]
ac <- alpha[, ctl, drop = FALSE]
W <- Y[, ctl] %*% t(ac) %*% solve(ac %*% t(ac))
newY <- Y - W %*% alpha
}
if (average) {
newY <- ((1 / apply(M, 2, sum)) * t(M)) %*% newY
}
if (!return.info) {
return(newY)
} else {
return(list(
newY = newY, M = M, fullalpha = fullalpha,
rsvd_k_options = c(
"m-ncol(M)" = m - ncol(M),
"sum(ctl)" = sum(ctl),
"rsvd_prop_propEigen" = ceiling(propEigen*min(dim(Y0))))
)
)
}
}
residop_fast <-
function(A, B) {
return(A - B %*% solve(t(B) %*% B) %*% (t(B) %*% A))
}
tological <-
function(ctl, n) {
ctl2 <- rep(FALSE, n)
ctl2[ctl] <- TRUE
return(ctl2)
}
library(roxygen2)
roxygenise()
library(roxygen2)
roxygenise()
library(scMerge)
help(scMerge)
require(SingleCellExperiment)
# Loading example data
data("sce_mESC")
# Previously computed stably expressed genes
data("segList_ensemblGeneID")
# Running an example data with minimal inputs
sce_mESC<- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge",fast_svd = FALSE)
sce_mESC <- runPCA(sce_mESC, exprs_value = "scMerge")
library(scater)
sce_mESC <- runPCA(sce_mESC, exprs_value = "scMerge")
plotPCA(sce_mESC)
library(scMerge)
require(SingleCellExperiment)
data("sce_mESC")
data("segList_ensemblGeneID")
sce_mESC<- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge")
scMerge()
sce_mESC
scater::plotPCA(sce_mESC)
scater::plotPCA(sce_mESC, "counts")
?plotPCA
scater::plotPCA(sce_mESC, exprs_values = "counts")
scater::plotPCA(sce_mESC, exprs_values = "logcounts")
scater::plotPCA(sce_mESC, exprs_values = "logcounts", colour_by = "batch", shape = "cell_type")
scater::plotPCA(sce_mESC, exprs_values = "logcounts", colour_by = "batch", shape = "cellTypes")
scater::plotPCA(sce_mESC, exprs_values = "scMerge", colour_by = "batch", shape = "cellTypes")
scater::plotPCA(sce_mESC, exprs_values = "scMerge", colour_by = "cellTypes", shape = "batch")
library(roxygen2)
library(scMerge)
sce_combine = sce_mESC;
ctl = segList_ensemblGeneID$mouse$mouse_scSEG;
kmeansK = c(1,3,3,1,1);
assay_name = c("scMerge_k10", "scMerge_k20");
exprs = "logcounts";
hvg_exprs = "counts";
marker = NULL;
marker_list = NULL;
ruvK = c(10, 20);
replicate_prop = 0.5;
cell_type = NULL;
cell_type_match = FALSE;
cell_type_inc = NULL;
fast_svd = FALSE;
propEigen = 0.1;
dist = "cor";
WV = NULL;
WV_marker = NULL;
return_all_RUV = FALSE;
return_sce = TRUE
## Checking input expression
if(is.null(exprs)){
stop("exprs is NULL.")
}
if(is.null(assay_name)){
stop("assay_name is NULL")
}
if(return_all_RUV){
message("You chose return_all_RUV = TRUE, the result will contain all RUV computations. This could be a very large object.")
## We need an assay_name for every ruvK, if return_all_RUV is TRUE
if(length(assay_name) != length(ruvK)){
stop("You chose return_all_RUV = TRUE. In this case, the length of assay_name must be equal to the length of ruvK")
}
}
## Checking input expression assay name in SCE object
if(!exprs %in% assayNames(sce_combine)){
stop(paste("No assay named", exprs))
}
## Extracting data matrix from SCE object
exprs_mat <- SummarizedExperiment::assay(sce_combine, exprs)
sce_rownames <- rownames(sce_combine)
## Checking if any rows or columns are purely zeroes
if (sum(rowSums(exprs_mat) == 0) != 0 | sum(colSums(exprs_mat) == 0) != 0) {
stop("There are rows or columns that are all zeros. Please remove it.")
}
## Checking negative controls input
if (is.null(ctl)) {
stop("Negative control genes are needed. \n")
} else {
if (class(ctl) == "character") {
ctl <- which(sce_rownames %in% ctl)
}
if (length(ctl) == 0) {
stop("Could not find any negative control genes in the row names of the expression matrix", call. = FALSE)
}
}
## Checking the batch info
if (is.null(sce_combine$batch)) {
stop("Could not find a 'batch' column in colData(sce_combine)", call. = FALSE)
}
if(class(sce_combine$batch) == "factor"){
sce_batch <- droplevels(sce_combine$batch)
} else {
sce_batch <- sce_combine$batch
}
## Finding pseudo-replicates
repMat <- scReplicate(sce = sce_combine,
batch = sce_batch,
kmeansK = kmeansK,
exprs = exprs,
hvg_exprs = hvg_exprs,
marker = marker,
marker_list = marker_list,
replicate_prop = replicate_prop,
cell_type = cell_type,
cell_type_match = cell_type_match,
cell_type_inc = cell_type_inc,
dist = dist,
WV = WV,
WV_marker = WV_marker)
cat("Dimension of the replicates mapping matrix \n")
print(dim(repMat))
cat("\n")
## Performing RUV normalisation
cat("Performing RUV normalisation... This might take a few minutes... \n")
ruv3res <- scRUVIII(Y = t(exprs_mat),
M = repMat,
ctl = ctl,
k = ruvK,
batch = sce_batch,
fullalpha = NULL,
cell_type = cell_type,
return.info = TRUE,
return_all_RUV = return_all_RUV,
fast_svd = fast_svd,
propEigen = propEigen)
# YXL: NEED FIX
##
# if (return_all_RUV) {
#   return(res = list(
#     scRUV = ruv3res,
#     mnc = mnc,
#     kmeans = kmeans_res
#   ))
# }
# if (return_sce) {
#   if (is.null(assay_name)) {
#     assay_name <- paste("scMerge_RUVk", ruv3res$k, sep = "")
#   }
#   assay(sce_combine, assay_name) <- t(ruv3res$newY)
#   cat(paste("Return assay named \n", assay_name))
#   return(sce_combine)
# } else {
#   return(res = list(
#     normalised_matrix = ruv3res$newY,
#     scRUV_res = ruv3res,
#     scRep_res = repMat
#   ))
# } ## End return_sce criterion
roxygenise()
ruv3res <- scRUVIII(Y = t(exprs_mat),
M = repMat,
ctl = ctl,
k = ruvK,
batch = sce_batch,
fullalpha = NULL,
cell_type = cell_type,
return.info = TRUE,
return_all_RUV = return_all_RUV,
fast_svd = fast_svd,
propEigen = propEigen)
sce_final_result = sce_combine
ruv3res
ruvK
return_all_RUV
return_all_RUV = TRUE
if(return_all_RUV){
message("You chose return_all_RUV = TRUE, the result will contain all RUV computations. This could be a very large object.")
## We need an assay_name for every ruvK, if return_all_RUV is TRUE
if(length(assay_name) != length(ruvK)){
stop("You chose return_all_RUV = TRUE. In this case, the length of assay_name must be equal to the length of ruvK")
}
}
sce_final_result = sce_combine
if(!return_all_RUV){
## If return_all_RUV is FALSE, then scRUVIII should've just returned with a single result (ruv3res_optimal)
assay(sce_final_result, assay_name) <- t(ruv3res$newY)
metadata(sce_final_result) = list(
"ruvK" = ruvK,
"ruvK_optimal" = ruv3res$optimal_ruvK
)
} else{
## if return_all_RUV is TRUE, then the previous check ensured assay_name is not NULL and matches the length of ruvK
## And the scRUVIII should've just returned with a single result (ruv3res_optimal)
listNewY = lapply(ruv3res[names(ruv3res) != "optimal_ruvK"], function(x){t(x$newY)})
for(i in 1:length(listNewY)){
assay(sce_final_result, assay_name[i]) <- listNewY[[i]]
}
}
return_all_RUV
ruv3res <- scRUVIII(Y = t(exprs_mat),
M = repMat,
ctl = ctl,
k = ruvK,
batch = sce_batch,
fullalpha = NULL,
cell_type = cell_type,
return.info = TRUE,
return_all_RUV = return_all_RUV,
fast_svd = fast_svd,
propEigen = propEigen)
sce_final_result = sce_combine
return_all_RUV
## if return_all_RUV is TRUE, then the previous check ensured assay_name is not NULL and matches the length of ruvK
## And the scRUVIII should've just returned with a single result (ruv3res_optimal)
listNewY = lapply(ruv3res[names(ruv3res) != "optimal_ruvK"], function(x){t(x$newY)})
assay_name
## if return_all_RUV is TRUE, then the previous check ensured assay_name is not NULL and matches the length of ruvK
## And the scRUVIII should've just returned with a single result (ruv3res_optimal)
listNewY = lapply(ruv3res[names(ruv3res) != "optimal_ruvK"], function(x){t(x$newY)})
for(i in 1:length(listNewY)){
assay(sce_final_result, assay_name[i]) <- listNewY[[i]]
}
sce_final_result
ruv3res$optimal_ruvK
ruvK
sce_final_result = sce_combine
if(!return_all_RUV){
## If return_all_RUV is FALSE, then scRUVIII should've just returned with a single result (ruv3res_optimal)
assay(sce_final_result, assay_name) <- t(ruv3res$newY)
} else{
## if return_all_RUV is TRUE, then the previous check ensured assay_name is not NULL and matches the length of ruvK
## And the scRUVIII should've just returned with a single result (ruv3res_optimal)
listNewY = lapply(ruv3res[names(ruv3res) != "optimal_ruvK"], function(x){t(x$newY)})
for(i in 1:length(listNewY)){
assay(sce_final_result, assay_name[i]) <- listNewY[[i]]
} ## End for loop
}
metadata(sce_final_result) = list(
"ruvK" = ruvK,
"ruvK_optimal" = ruv3res$optimal_ruvK
)
sce_final_result
sce_final_result %>% metadata()
library(magrittr)
sce_final_result %>% metadata()
library(roxygen2)
roxygenise()
roxygenise()
repMat
roxygenise()
help(scMerge)
help("scMerge")
sce_final_result
roxygenise()
roxygenise()
roxygenise()
library(pkgdown)
build_site()
roxygenise()
?person
roxygenise()
build_site()
library(roxygen2)
roxygenise()
install.packages("doSNOW")
install.packages("distr")
install.packages("distr")
roxygenise()
?scMerge
suppressPackageStartupMessages({
library(SingleCellExperiment)
library(scater)
})
# Loading example data
data("sce_mESC")
# Previously computed stably expressed genes
data("segList_ensemblGeneID")
# Running an example data with minimal inputs
sce_final_result = sce_combine
sce_mESC_normalised = scMerge(
sce_combine = sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge", fast_svd = TRUE)
if(!return_all_RUV){
## If return_all_RUV is FALSE, then scRUVIII should've just returned with a single result (ruv3res_optimal)
assay(sce_final_result, assay_name) <- t(ruv3res$newY)
} else{
## if return_all_RUV is TRUE, then the previous check ensured assay_name is not NULL and matches the length of ruvK
## And the scRUVIII should've just returned with a single result (ruv3res_optimal)
listNewY = lapply(ruv3res[names(ruv3res) != "optimal_ruvK"], function(x){t(x$newY)})
for(i in 1:length(listNewY)){
assay(sce_final_result, assay_name[i]) <- listNewY[[i]]
} ## End for loop
}
scater::plotPCA(sce_mESC_normalised, colour_by = "cellTypes", shape = "batch",
run_args = list(exprs_values = "logcounts"))
scater::plotPCA(sce_mESC_normalised, colour_by = "cellTypes", shape = "batch",
run_args = list(exprs_values = "logcounts"))
metadata(sce_final_result) = list(
"ruvK" = ruvK,
"ruvK_optimal" = ruv3res$optimal_ruvK,
"scRep_res" = repMat
)
pkgdown::build_site()
