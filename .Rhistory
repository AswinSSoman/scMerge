m = 10
n = 20000
n^2 >= m*n + m^3
m = 10
n = 20000
n^2 >= m*n + m^3
L = scMerge::ruvSimulate(m = m, n = n, nc = 50, nRep = 10)
Y = L$Y; M = L$M; ctl = L$ctl
microbenchmark::microbenchmark(
base::svd(Y),
base::svd(eigenMatMult(Y, t(Y))), times = 10
)
n^2
print(m*n + m^3)
m = 100
n = 2000
print(n^2)
print(m*n + m^3)
n^2 >= m*n + m^3
m = 1000
n = 200
print(n^2)
print(m*n + m^3)
n^2 >= m*n + m^3
L = scMerge::ruvSimulate(m = m, n = n, nc = 50, nRep = 10)
Y = L$Y; M = L$M; ctl = L$ctl
microbenchmark::microbenchmark(
base::svd(Y),
base::svd(eigenMatMult(Y, t(Y))), times = 10
)
dim(eigenMatMult(Y, t(Y)))
dim(Y)
m = 1000
n = 20
print(n^2)
print(m*n + m^3)
n^2 >= m*n + m^3
L = scMerge::ruvSimulate(m = m, n = n, nc = 50, nRep = 10)
Y = L$Y; M = L$M; ctl = L$ctl
microbenchmark::microbenchmark(
base::svd(Y),
base::svd(eigenMatMult(Y, t(Y))), times = 5
)
m = 1000
n = 20
print(n^2)
print(m*n + m^3)
n^2 >= m*n + m^3
L = scMerge::ruvSimulate(m = m, n = n, nc = n, nRep = 10)
Y = L$Y; M = L$M; ctl = L$ctl
microbenchmark::microbenchmark(
base::svd(Y),
base::svd(eigenMatMult(Y, t(Y))), times = 5
)
dim(Y)
m = 1000
n = 20
print(n^2)
print(m*n + m^3)
n^2 >= m*n + m^3
roxygenise()
t1 = Sys.time()
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_fast",
fast_svd = TRUE,
rsvd_prop = 0.1)
roxygenise()
sessionInfo()
library(scMerge)
sessionInfo()
suppressPackageStartupMessages({
library(SingleCellExperiment)
library(scMerge)
library(scMerge.data)
library(scater)
})
## mouse ESC data
data("sce_mESC", package = "scMerge.data")
## single-cell stably expressed gene list
data("segList_ensemblGeneID")
## single-cell stably expressed gene list
data("segList_ensemblGeneID")
t1 = Sys.time()
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_classical")
t2 = Sys.time()
t2 - t1
L = scMerge::ruvSimulate(m = 1000, n = 100, nc = 50, nRep = 10)
Y = L$Y; M = L$M; ctl = L$ctl
improved1 = fastRUVIII(Y = Y, M = M, ctl = ctl, k = 20, fast_svd = FALSE)
improved1
improved1 = fastRUVIII(Y = Y, M = M, ctl = ctl, k = 20, fast_svd = FALSE)
improved2 = fastRUVIII(Y = Y, M = M, ctl = ctl, k = 20, fast_svd = TRUE, rsvd_prop = 0.1)
old = ruv::RUVIII(Y = Y, M = M, ctl = ctl, k = 20)
all.equal(improved1, old)
all.equal(improved2, old)
L = scMerge::ruvSimulate(m = 700, n = 20000, nc = 50, nRep = 10)
Y = L$Y; M = L$M; ctl = L$ctl
dim(Y)
improved1 = fastRUVIII(Y = Y, M = M, ctl = ctl, k = 20, fast_svd = FALSE)
L = scMerge::ruvSimulate(m = 700, n = 10000, nc = 50, nRep = 10)
Y = L$Y; M = L$M; ctl = L$ctl
L = scMerge::ruvSimulate(m = 700, n = 10000, nc = 50, nRep = 10)
Y = L$Y; M = L$M; ctl = L$ctl
k = 20
fast_svd = FALSE
profvis::profvis({
if (is.data.frame(Y)) {
Y <- data.matrix(Y)
}
m <- nrow(Y)
n <- ncol(Y)
M <- ruv::replicate.matrix(M)
ctl <- tological(ctl, n)
## Check the inputs
if (inputcheck) {
if (m > n) {
warning("m is greater than n!  This is not a problem itself, but may indicate that you need to transpose your data matrix.  Please ensure that rows correspond to observations (e.g. microarrays) and columns correspond to features (e.g. genes).")
}
if (sum(is.na(Y)) > 0) {
warning("Y contains missing values.  This is not supported.")
}
if (sum(Y == Inf, na.rm = TRUE) + sum(Y == -Inf, na.rm = TRUE) >
0) {
warning("Y contains infinities.  This is not supported.")
}
}
## RUV1 is a reprocessing step for RUVIII
Y <- ruv::RUV1(Y, eta, ctl, include.intercept = include.intercept)
if(fast_svd){
svd_k = min(m - ncol(M), sum(ctl), ceiling(rsvd_prop*m), na.rm = TRUE)
} else {
svd_k = min(m - ncol(M), sum(ctl), na.rm = TRUE)
}
## m represent the number of samples/observations
## ncol(M) represent the number of replicates
## If the replicate matrix is such that we have more replicates than samples, then RUV3 is not appropriate, thus, we return the
## Original input matrix
if (ncol(M) >= m | k == 0) {
newY <- Y
fullalpha <- NULL
} else {
if (is.null(fullalpha)) { ## The main RUVIII process
## Applies the residual operator of a matrix M to a matrix Y
## Y0 has the same dimensions as Y, i.e. m rows (observations) and n columns (genes).
Y0 <- eigenResidop(Y, M)
if(fast_svd){
svdObj = rsvd::rsvd(Y0, k = svd_k)
} else {
svdObj = base::svd(Y0)
} ## End if(fast_svd)
fullalpha = eigenMatMult(t(svdObj$u[, 1:svd_k, drop = FALSE]), Y)
} ## End is.null(fullalpha)
#########################################################
## Regardless of the availibility of fullalpha, we need to compute this normalisation.
alpha <- fullalpha[1:min(k, nrow(fullalpha)), , drop = FALSE]
ac <- alpha[, ctl, drop = FALSE]
W <- Y[, ctl] %*% t(ac) %*% solve(ac %*% t(ac))
newY <- Y - eigenMatMult(W, alpha)
} ## End else(ncol(M) >= m | k == 0)
if (average) { ## If average over the replicates is needed. This is ignored in scMerge.
newY <- ((1 / apply(M, 2, sum)) * t(M)) %*% newY
}
})
############################
# residop_fast <-
#   function(A, B) {
#     return(A - B %*% (solve(t(B) %*% B) %*% (t(B) %*% A)))
#   }
############################
tological <- function(ctl, n) {
ctl2 <- rep(FALSE, n)
ctl2[ctl] <- TRUE
return(ctl2)
}
profvis::profvis({
if (is.data.frame(Y)) {
Y <- data.matrix(Y)
}
m <- nrow(Y)
n <- ncol(Y)
M <- ruv::replicate.matrix(M)
ctl <- tological(ctl, n)
## Check the inputs
if (inputcheck) {
if (m > n) {
warning("m is greater than n!  This is not a problem itself, but may indicate that you need to transpose your data matrix.  Please ensure that rows correspond to observations (e.g. microarrays) and columns correspond to features (e.g. genes).")
}
if (sum(is.na(Y)) > 0) {
warning("Y contains missing values.  This is not supported.")
}
if (sum(Y == Inf, na.rm = TRUE) + sum(Y == -Inf, na.rm = TRUE) >
0) {
warning("Y contains infinities.  This is not supported.")
}
}
## RUV1 is a reprocessing step for RUVIII
Y <- ruv::RUV1(Y, eta, ctl, include.intercept = include.intercept)
if(fast_svd){
svd_k = min(m - ncol(M), sum(ctl), ceiling(rsvd_prop*m), na.rm = TRUE)
} else {
svd_k = min(m - ncol(M), sum(ctl), na.rm = TRUE)
}
## m represent the number of samples/observations
## ncol(M) represent the number of replicates
## If the replicate matrix is such that we have more replicates than samples, then RUV3 is not appropriate, thus, we return the
## Original input matrix
if (ncol(M) >= m | k == 0) {
newY <- Y
fullalpha <- NULL
} else {
if (is.null(fullalpha)) { ## The main RUVIII process
## Applies the residual operator of a matrix M to a matrix Y
## Y0 has the same dimensions as Y, i.e. m rows (observations) and n columns (genes).
Y0 <- eigenResidop(Y, M)
if(fast_svd){
svdObj = rsvd::rsvd(Y0, k = svd_k)
} else {
svdObj = base::svd(Y0)
} ## End if(fast_svd)
fullalpha = eigenMatMult(t(svdObj$u[, 1:svd_k, drop = FALSE]), Y)
} ## End is.null(fullalpha)
#########################################################
## Regardless of the availibility of fullalpha, we need to compute this normalisation.
alpha <- fullalpha[1:min(k, nrow(fullalpha)), , drop = FALSE]
ac <- alpha[, ctl, drop = FALSE]
W <- Y[, ctl] %*% t(ac) %*% solve(ac %*% t(ac))
newY <- Y - eigenMatMult(W, alpha)
} ## End else(ncol(M) >= m | k == 0)
if (average) { ## If average over the replicates is needed. This is ignored in scMerge.
newY <- ((1 / apply(M, 2, sum)) * t(M)) %*% newY
}
})
inputcheck = TRUE
profvis::profvis({
if (is.data.frame(Y)) {
Y <- data.matrix(Y)
}
m <- nrow(Y)
n <- ncol(Y)
M <- ruv::replicate.matrix(M)
ctl <- tological(ctl, n)
## Check the inputs
if (inputcheck) {
if (m > n) {
warning("m is greater than n!  This is not a problem itself, but may indicate that you need to transpose your data matrix.  Please ensure that rows correspond to observations (e.g. microarrays) and columns correspond to features (e.g. genes).")
}
if (sum(is.na(Y)) > 0) {
warning("Y contains missing values.  This is not supported.")
}
if (sum(Y == Inf, na.rm = TRUE) + sum(Y == -Inf, na.rm = TRUE) >
0) {
warning("Y contains infinities.  This is not supported.")
}
}
## RUV1 is a reprocessing step for RUVIII
Y <- ruv::RUV1(Y, eta, ctl, include.intercept = include.intercept)
if(fast_svd){
svd_k = min(m - ncol(M), sum(ctl), ceiling(rsvd_prop*m), na.rm = TRUE)
} else {
svd_k = min(m - ncol(M), sum(ctl), na.rm = TRUE)
}
## m represent the number of samples/observations
## ncol(M) represent the number of replicates
## If the replicate matrix is such that we have more replicates than samples, then RUV3 is not appropriate, thus, we return the
## Original input matrix
if (ncol(M) >= m | k == 0) {
newY <- Y
fullalpha <- NULL
} else {
if (is.null(fullalpha)) { ## The main RUVIII process
## Applies the residual operator of a matrix M to a matrix Y
## Y0 has the same dimensions as Y, i.e. m rows (observations) and n columns (genes).
Y0 <- eigenResidop(Y, M)
if(fast_svd){
svdObj = rsvd::rsvd(Y0, k = svd_k)
} else {
svdObj = base::svd(Y0)
} ## End if(fast_svd)
fullalpha = eigenMatMult(t(svdObj$u[, 1:svd_k, drop = FALSE]), Y)
} ## End is.null(fullalpha)
#########################################################
## Regardless of the availibility of fullalpha, we need to compute this normalisation.
alpha <- fullalpha[1:min(k, nrow(fullalpha)), , drop = FALSE]
ac <- alpha[, ctl, drop = FALSE]
W <- Y[, ctl] %*% t(ac) %*% solve(ac %*% t(ac))
newY <- Y - eigenMatMult(W, alpha)
} ## End else(ncol(M) >= m | k == 0)
if (average) { ## If average over the replicates is needed. This is ignored in scMerge.
newY <- ((1 / apply(M, 2, sum)) * t(M)) %*% newY
}
})
eta = NULL
profvis::profvis({
if (is.data.frame(Y)) {
Y <- data.matrix(Y)
}
m <- nrow(Y)
n <- ncol(Y)
M <- ruv::replicate.matrix(M)
ctl <- tological(ctl, n)
## Check the inputs
if (inputcheck) {
if (m > n) {
warning("m is greater than n!  This is not a problem itself, but may indicate that you need to transpose your data matrix.  Please ensure that rows correspond to observations (e.g. microarrays) and columns correspond to features (e.g. genes).")
}
if (sum(is.na(Y)) > 0) {
warning("Y contains missing values.  This is not supported.")
}
if (sum(Y == Inf, na.rm = TRUE) + sum(Y == -Inf, na.rm = TRUE) >
0) {
warning("Y contains infinities.  This is not supported.")
}
}
## RUV1 is a reprocessing step for RUVIII
Y <- ruv::RUV1(Y, eta, ctl, include.intercept = include.intercept)
if(fast_svd){
svd_k = min(m - ncol(M), sum(ctl), ceiling(rsvd_prop*m), na.rm = TRUE)
} else {
svd_k = min(m - ncol(M), sum(ctl), na.rm = TRUE)
}
## m represent the number of samples/observations
## ncol(M) represent the number of replicates
## If the replicate matrix is such that we have more replicates than samples, then RUV3 is not appropriate, thus, we return the
## Original input matrix
if (ncol(M) >= m | k == 0) {
newY <- Y
fullalpha <- NULL
} else {
if (is.null(fullalpha)) { ## The main RUVIII process
## Applies the residual operator of a matrix M to a matrix Y
## Y0 has the same dimensions as Y, i.e. m rows (observations) and n columns (genes).
Y0 <- eigenResidop(Y, M)
if(fast_svd){
svdObj = rsvd::rsvd(Y0, k = svd_k)
} else {
svdObj = base::svd(Y0)
} ## End if(fast_svd)
fullalpha = eigenMatMult(t(svdObj$u[, 1:svd_k, drop = FALSE]), Y)
} ## End is.null(fullalpha)
#########################################################
## Regardless of the availibility of fullalpha, we need to compute this normalisation.
alpha <- fullalpha[1:min(k, nrow(fullalpha)), , drop = FALSE]
ac <- alpha[, ctl, drop = FALSE]
W <- Y[, ctl] %*% t(ac) %*% solve(ac %*% t(ac))
newY <- Y - eigenMatMult(W, alpha)
} ## End else(ncol(M) >= m | k == 0)
if (average) { ## If average over the replicates is needed. This is ignored in scMerge.
newY <- ((1 / apply(M, 2, sum)) * t(M)) %*% newY
}
})
fullalpha = NULL
profvis::profvis({
if (is.data.frame(Y)) {
Y <- data.matrix(Y)
}
m <- nrow(Y)
n <- ncol(Y)
M <- ruv::replicate.matrix(M)
ctl <- tological(ctl, n)
## Check the inputs
if (inputcheck) {
if (m > n) {
warning("m is greater than n!  This is not a problem itself, but may indicate that you need to transpose your data matrix.  Please ensure that rows correspond to observations (e.g. microarrays) and columns correspond to features (e.g. genes).")
}
if (sum(is.na(Y)) > 0) {
warning("Y contains missing values.  This is not supported.")
}
if (sum(Y == Inf, na.rm = TRUE) + sum(Y == -Inf, na.rm = TRUE) >
0) {
warning("Y contains infinities.  This is not supported.")
}
}
## RUV1 is a reprocessing step for RUVIII
Y <- ruv::RUV1(Y, eta, ctl, include.intercept = include.intercept)
if(fast_svd){
svd_k = min(m - ncol(M), sum(ctl), ceiling(rsvd_prop*m), na.rm = TRUE)
} else {
svd_k = min(m - ncol(M), sum(ctl), na.rm = TRUE)
}
## m represent the number of samples/observations
## ncol(M) represent the number of replicates
## If the replicate matrix is such that we have more replicates than samples, then RUV3 is not appropriate, thus, we return the
## Original input matrix
if (ncol(M) >= m | k == 0) {
newY <- Y
fullalpha <- NULL
} else {
if (is.null(fullalpha)) { ## The main RUVIII process
## Applies the residual operator of a matrix M to a matrix Y
## Y0 has the same dimensions as Y, i.e. m rows (observations) and n columns (genes).
Y0 <- eigenResidop(Y, M)
if(fast_svd){
svdObj = rsvd::rsvd(Y0, k = svd_k)
} else {
svdObj = base::svd(Y0)
} ## End if(fast_svd)
fullalpha = eigenMatMult(t(svdObj$u[, 1:svd_k, drop = FALSE]), Y)
} ## End is.null(fullalpha)
#########################################################
## Regardless of the availibility of fullalpha, we need to compute this normalisation.
alpha <- fullalpha[1:min(k, nrow(fullalpha)), , drop = FALSE]
ac <- alpha[, ctl, drop = FALSE]
W <- Y[, ctl] %*% t(ac) %*% solve(ac %*% t(ac))
newY <- Y - eigenMatMult(W, alpha)
} ## End else(ncol(M) >= m | k == 0)
if (average) { ## If average over the replicates is needed. This is ignored in scMerge.
newY <- ((1 / apply(M, 2, sum)) * t(M)) %*% newY
}
})
profvis::profvis({ruv::residop(Y, M)})
profvis::profvis({ruv::residop(Y, M); eigenResidop(Y, M)})
profvis::profvis({ruv::residop(Y, M); eigenResidop(Y, M)})
profvis::profvis({ruv::residop(Y, M)})
profvis::profvis({; eigenResidop(Y, M)})
# Chunk 1: setup
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
# Chunk 2: loading packages
suppressPackageStartupMessages({
library(SingleCellExperiment)
library(scMerge)
library(scMerge.data)
library(scater)
})
## mouse ESC data
data("sce_mESC", package = "scMerge.data")
## single-cell stably expressed gene list
data("segList_ensemblGeneID")
## single-cell stably expressed gene list
data("segList_ensemblGeneID")
t1 = Sys.time()
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_classical")
t2 = Sys.time()
t2 - t1
dim(sce_mESC)
roxygenise()
t3 = Sys.time()
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_fast",
fast_svd = TRUE,
rsvd_prop = 0.1)
t4 = Sys.time()
t4 - t3
roxygenise()
t3 = Sys.time()
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_fast",
fast_svd = TRUE,
rsvd_prop = 0.1)
t4 = Sys.time()
t4 - t3
sce_mESC <- scater::runPCA(sce_mESC,
exprs_values = "scMerge_fast")
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch") +
labs(title = "fast_svd yields similar results to the default version")
roxygenise()
t3 = Sys.time()
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_fast",
fast_svd = TRUE,
rsvd_prop = 0.1)
t4 = Sys.time()
t4 - t3
roxygenise()
t1 = Sys.time()
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_classical")
t2 = Sys.time()
t2 - t1
L = scMerge::ruvSimulate(m = 700, n = 10000, nc = 50, nRep = 10)
Y = L$Y; M = L$M; ctl = L$ctl
improved1 = scMerge::fastRUVIII(Y = Y, M = M, ctl = ctl, k = 20, fast_svd = FALSE)
old = ruv::RUVIII(Y = Y, M = M, ctl = ctl, k = 20)
microbenchmark::microbenchmark(improved1 = scMerge::fastRUVIII(Y = Y, M = M, ctl = ctl, k = 20, fast_svd = FALSE), times = 1)
microbenchmark::microbenchmark(old = ruv::RUVIII(Y = Y, M = M, ctl = ctl, k = 20), times = 1)
roxygenise()
microbenchmark::microbenchmark(improved1 = scMerge::fastRUVIII(Y = Y, M = M, ctl = ctl, k = 20, fast_svd = FALSE), times = 1)
microbenchmark::microbenchmark(Y %*% M, times = 1)
dim(Y)
dim(M)
microbenchmark::microbenchmark(t(Y) %*% M, times = 1)
microbenchmark::microbenchmark(t(Y) %*% M,
eigenMatMult(t(Y), M), times = 1)
L = scMerge::ruvSimulate(m = 700, n = 1000, nc = 50, nRep = 10)
Y = L$Y; M = L$M; ctl = L$ctl
improved1 = scMerge::fastRUVIII(Y = Y, M = M, ctl = ctl, k = 20, fast_svd = FALSE)
improved2 = scMerge::fastRUVIII(Y = Y, M = M, ctl = ctl, k = 20, fast_svd = TRUE, rsvd_prop = 0.1)
old = ruv::RUVIII(Y = Y, M = M, ctl = ctl, k = 20)
all.equal(improved1, old)
all.equal(improved2, old)
remove.packages("scMerge")
remove.packages("fakePackage")
